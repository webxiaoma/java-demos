---
sidebarDepth: 1
meta:
  - name: keywords
    content:  Java修饰符 Java 修饰符 
  - name: description
    content: 本文为Java修饰符
---

# Java修饰符

## 访问修饰符

`Java`的修饰符用于定义类，修饰方法或变量


| **访问范围** |	**private** |	**friendly(默认)** |	**protected** |	**public** |
|----|----|----|----|----|
| 同一个类   |   可访问 |  可访问  |  可访问  |  可访问  |
| 同一包中的其他类  |  不可访问  |  可访问  |  可访问  |  可访问  |
| 不同包中的子类   |  不可访问  |  不可访问  |  可访问  | 可访问   |
|  不同包中的非子类  |  不可访问  |  不可访问  | 不可访问   | 可访问  |
				

**注意** `private` 和 `protected` 一般修饰内部类


:::tip 继承提示
- 父类中声明为 `public` 的方法在子类中也必须为 `public`。
- 父类中声明为 `protected` 的方法在子类中要么声明为 `protected`，要么声明为 `public`，不能声明为 `private`。
- 父类中声明为 `private` 的方法，不能够被继承。
:::



## 非访问修饰符

-  `static` 静态修饰符
-  `final` 修饰符
-  `abstract` 抽象修饰符

###  `static` 静态修饰符
 用来修饰类方法和类变量 (不能将方法体内的局部变量声明为`static`)

**静态变量与实例变量**

1. 静态变量
- 运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。
- 在类的内部，可以在任何方法内直接访问静态变量。
- 在其他类中，可以通过类名访问该类中的静态变量。

2. 实例变量
- 每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。
- 在类的内部，可以在非静态方法中直接访问实例变量。
- 在本类的静态方法或其他类中则需要通过类的实例对象进行访问。


**静态方法与实例方法**

- 静态方法不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用 `this` 关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。另外，和 `this` 关键字一样，super 关键字也与类的特定实例相关，所以在静态方法中也不能使用 `super` 关键字。
- 在实例方法中可以直接访问所属类的静态变量、静态方法、实例变量和实例方法。


**静态代码块**

- 静态代码块类似于一个方法，但它不可以存在于任何方法体中。
- 静态代码块可以置于类中的任何地方，类中可以有多个静态初始化块。 
- Java 虚拟机在加载类时执行静态代码块，所以很多时候会将一些只需要进行一次的初始化操作都放在 static 代码块中进行。
- 如果类中包含多个静态代码块，则 Java 虚拟机将按它们在类中出现的顺序依次执行它们，每个静态代码块只会被执行一次。
- 静态代码块与静态方法一样，不能直接访问类的实例变量和实例方法，而需要通过类的实例对象来访问。

```java

public class HelloA {
    public HelloA(){
        System.out.println("I'm A construct method code block");
    }
    {
        System.out.println("I'm A construct code block");
    }

    static {
        System.out.println("I'm A static code block");
    }
    public static void main(String[] args) {
        new HelloA();
        new HelloA();

    }
}

/** 结果
I'm A static code block
I'm A construct code block
I'm A construct method code block
I'm A construct code block
I'm A construct method code block
**/
```

### `final` 修饰类

用来修饰类、方法和变量，`final` 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。

1. **final 修饰类中的变量**

表示该变量一旦被初始化便不可改变，这里不可改变的意思对基本类型变量来说是其值不可变，而对对象引用类型变量来说其引用不可再变。其初始化可以在两个地方：一是其定义处，也就是说在 final 变量定义时直接给其赋值；二是在构造方法中。这两个地方只能选其一，要么在定义时给值，要么在构造方法中给值，不能同时既在定义时赋值，又在构造方法中赋予另外的值。

2. **final 修饰类中的方法**

说明这种方法提供的功能已经满足当前要求，不需要进行扩展，并且也不允许任何从此类继承的类来重写这种方法，但是继承仍然可以继承这个方法，也就是说可以直接使用。在声明类中，一个 final 方法只被实现一次。

3. **final 修饰类**

表示该类是无法被任何其他类继承的，意味着此类在一个继承树中是一个叶子类，并且此类的设计已被认为很完美而不需要进行修改或扩展。




### `abstract`抽象修饰

使用`abstract`修饰的类就是抽象类，使用`abstract`修饰的方法就是抽方

**抽象类：**
- 如果一个方法被声明为抽象的，那么这个类也必须声明为抽象的。而一个抽象类中，可以有 0~n 个抽象方法，以及 0~n 个具体方法。
- 抽象类不能实例化，也就是不能使用 `new` 关键字创建对象。


**抽象方法：**
- 抽象方法没有方法体
- 抽象方法必须存在于抽象类中
- 使用 `abstract` 关键字修饰抽象方法时不能使用 `private` 修饰
- 子类重写父类时，必须重写父类所有的抽象方法
